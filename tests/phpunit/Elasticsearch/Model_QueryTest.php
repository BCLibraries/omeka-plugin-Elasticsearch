<?php

require_once __DIR__ . '/../../../libraries/Elasticsearch/Model/Query.php';

use PHPUnit\Framework\TestCase;

class Model_QueryTest extends TestCase
{
    /**
     * @var array
     */
    public $expected;

    /**
     * @var Elasticsearch_Model_Query
     */
    protected $query;

    public function setUp(): void
    {
        parent::setUp(); // TODO: Change the autogenerated stub

        $aggs = new stdClass();
        $aggs->foo = 'bar';
        $agg_list = $this->createMock(Elasticsearch_Model_AggregationList::class);
        $agg_list->method('toObject')
            ->willReturn($aggs);

        $subq1 = $this->createMock(Elasticsearch_Model_SubQuery::class);
        $subq1->method('toArray')
            ->willReturn(['subquery_1']);

        $subq2 = $this->createMock(Elasticsearch_Model_SubQuery::class);
        $subq2->method('toArray')
            ->willReturn(['subquery_2']);

        $subqueries = [$subq1, $subq2];

        $filter1 = $this->createMock(Elasticsearch_Model_SubQuery::class);
        $filter1->method('toArray')
            ->willReturn(['filter_1']);

        $filter2 = $this->createMock(Elasticsearch_Model_SubQuery::class);
        $filter2->method('toArray')
            ->willReturn(['filter_2']);

        $filters = [$filter1, $filter2];

        $this->query = Elasticsearch_Model_Query::build($subqueries, $filters, $agg_list);
    }

    public function testQueryBuildsArray(): void
    {
        $aggs = new stdClass();
        $aggs->foo = 'bar';
        $expected = [
            'query' => [
                'bool' => [
                    'must' => [['subquery_1'], ['subquery_2']],
                    'filter' => [['filter_1'], ['filter_2']]

                ]
            ],
            'aggregations' => $aggs,
            'sort' => ['_score']
        ];

        $this->assertEquals($expected, $this->query->toArray());
    }

    public function testSettingOffsetWorks(): void
    {
        $aggs = new stdClass();
        $aggs->foo = 'bar';
        $expected = [
            'query' => [
                'bool' => [
                    'must' => [['subquery_1'], ['subquery_2']],
                    'filter' => [['filter_1'], ['filter_2']]

                ]
            ],
            'aggregations' => $aggs,
            'sort' => ['_score'],
            'from' => 13
        ];

        $this->query->offset(13);
        $this->assertEquals($expected, $this->query->toArray());
    }

    public function testSettingLimitWorks(): void
    {
        $aggs = new stdClass();
        $aggs->foo = 'bar';
        $expected = [
            'query' => [
                'bool' => [
                    'must' => [['subquery_1'], ['subquery_2']],
                    'filter' => [['filter_1'], ['filter_2']]

                ]
            ],
            'aggregations' => $aggs,
            'sort' => ['_score'],
            'size' => 5
        ];

        $this->query->limit(5);
        $this->assertEquals($expected, $this->query->toArray());
    }

    public function testSortWorks(): void
    {
        $sort = $this->createMock(Elasticsearch_Model_Sort::class);
        $sort->method('toArray')
            ->willReturn(['foo' => 'asc']);
        $aggs = new stdClass();
        $aggs->foo = 'bar';
        $expected = [
            'query' => [
                'bool' => [
                    'must' => [['subquery_1'], ['subquery_2']],
                    'filter' => [['filter_1'], ['filter_2']]

                ]
            ],
            'aggregations' => $aggs,
            'sort' => [['foo' => 'asc'], '_score']
        ];

        $this->query->sort($sort);
        $this->assertEquals($expected, $this->query->toArray());
    }

    public function testInterfaceIsFluent(): void
    {
        $query_after_methods = $this->query->limit(12)
            ->offset(2)
            ->sort($this->createMock(Elasticsearch_Model_Sort::class));
        $this->assertSame($query_after_methods, $this->query);
    }
}
